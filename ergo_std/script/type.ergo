{type,match,map,iter,array,eval,^_} = ergo plugin

basic-type = fn :check -> :a -> !match :a [
    :check
    fn (check :m) -> :m
    (check _) -> ()
]

## Match maps with specific keys and value types.
## 
## Arguments: `(Map :map)`
##
## `map` should contain the expected keys and their corresponding value types.
##
## Returns a type that will check arguments like typical type functions.
MapValues = fn (type:Map :fields) -> basic-type <| pat :out -> type:Map :m -> {
    bind :out <| !map:from <| iter:map (fn (type:MapEntry: :k :v) -> type:MapEntry: :k (fields::k :v)) :m
}

## Match maps where all keys match a specific type and all values match a specific type.
## 
## Arguments: `(Function :key-type) (Function :value-type)`
##
## Returns a type that will check arguments like typical type functions.
MapOf = fn (type:Function :keys) (type:Function :values) -> {
    basic-type <| pat :out -> type:Map :m -> {
        bind :out <| !map:from <| iter:map (fn (type:MapEntry: (keys :k) (values :v)) -> type:MapEntry: :k :v) :m
    }
}

## Match arrays with specific value types.
## 
## Arguments: `(Array :array)`
##
## `array` should contain the expected value types for each entry in the array.
##
## Returns a type that will check arguments like typical type functions.
ArrayValues = fn (type:Array :tps) -> basic-type <| pat :out -> type:Array :a -> {
    bind :out <| !array:from <| iter:map (fn [:f,:v] -> f :v ) <| iter:zip :tps :a
}

## Match arrays where all values match a specific type.
## 
## Arguments: `(Function :type)`
##
## Returns a type that will check arguments like typical type functions.
ArrayOf = fn (type:Function :tp) -> {
    basic-type (pat :out -> type:Array :a -> { bind :out <| !array:from <| iter:map :tp :a })
}

## Match a value allowing `Unset` values.
##
## Pattern Arguments: `:target`
optional = pat :out -> :v -> !match :v [
    type:Unset -> ()
    :other -> bind :out :other
]

## Match a value disallowing `Unset` values.
##
## This is only useful if the binding argument would normally accept an `Unset` value.
##
## Pattern Arguments: `:target`
required = pat :out -> :v -> !match :v [
    type:Unset -> !type:Error: (source=:out) "required value missing"
    :other -> bind :out :other
]

## Create an enumeration type.
## 
## Arguments: `(String :name) (Map :variants)`
## 
## Enumeration (sum) types have one of a closed set of inner types.
## The first argument should be the unique name of the type (as would be passed to [new](self:new)).
## The second argument should be a map of the variant keys and expectected types. For example:
## ```ergo
## MapResult = enum MapResult {
##   Ok = :Map
##   Error = :String
## }
## ok = MapResult:Ok {}
## err = MapResult:Error "oh no"
## MapResult :r = :ok
## MapResult :e = :err
## MapResult:Ok :m = :ok
## ```
## The variant values should be values supporting function calls and binding/pattern calls.
enum = fn (type:String :name) (type:Map :variants) -> {
    # Create new type for enum
    tp = type:new :name <| :a -> !match :a [
        fn :which ^:args -> { ::which = variants::which ^:args }
        pat :which ^:args -> { ::which = variants::which ^!:args } -> ()
    ]
    # Create map interface for enum variants
    key-to-accessor = fn :key -> :a -> !match :a [
        fn ^:args -> tp: :key ^:args
        pat ^:args -> tp: !:key ^!:args -> ()
    ]
    accessor = eval <| :variants | iter:map (fn (type:MapEntry: :key _) -> type:MapEntry: :key (key-to-accessor :key)) | map:from
    # Wrap the accessor to add a way to check for `tp` using it.
    :a -> !match :a [index :arg -> accessor::arg,:tp]
}

## Create a structured type.
## 
## Arguments: `(String :name) (Map :fields)`
## 
## Structured (product) types are a set of keyed values.
## Note this merely makes a new type with a `MapValues` type checker.
## 
## The first argument should be the unique name of the type (as would be passed to `type:new`).
## The second argument should be a map of the field keys and expected types. For example:
## ```ergo
## StringPair = struct StringPair {
##     first = :String
##     second = :String
## }
## pair = StringPair: { first = hello, second = world }
## StringPair _ = :pair
## StringPair: {first,second} = :pair
## ```
struct = fn (type:String :name) (type:Map :fields) -> type:new :name <| MapValues :fields

{optional,required,MapValues,MapOf,ArrayValues,ArrayOf,enum,struct}
