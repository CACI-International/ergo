plugin = ergo plugin

## Create a value that will evaluate to the first argument which successfully binds.
## 
## Arguments: `(Array :cases)`
##
## This is a shortcut for `:a -> match $$a $$cases`.
matches = fn :cases -> :a -> plugin:match $a $cases

mdoc = ergo doc
mnet = ergo net
mtest = ergo test
mtype = ergo type

## Load a remote archive.
##
## Fetches the archive with `net:unarchive ^enter`, and loads the archive from the root directory.
## Caches the returned value.
##
## All arguments are forwarded to `std:net:http`.
ergo-remote = fn ^:args -> ergo <| plugin:value:cache <| mnet:unarchive ^enter ^$args

## Return any bound value as-is.
##
## Particularly useful as a case in `match` calls.
pass = :v -> $v

## Use a default value if Unset.
##
## Arguments: `:target as :value`
##
## If the value bound to the result is `Unset`, `value` is used instead.
##
## ### Example Usage
## ```ergo
## default :my-value as [] = $$maybe-an-array
## func = fn (opt-arg = default :arg as []) -> {...}
## ```
default = fn :target as :default-value -> :v -> {
    $target =  plugin:match $v [$unset -> $default-value, $pass]
}

## Partially apply a function.
##
## Arguments: `(Function :func) ^:args`
##
## Returns a `Function` that, when called, will call the original function with the original arguments
## and any extra arguments of the call.
##
## ### Example Usage
## ```ergo
## f = fn :a :b :c -> [$$a,$$b,$$c]
## part = Function:partial $$f 1 2
## [1,2,3] = part 3
## [1,2,a] = part a
## ```
partial = fn :f ^:args -> fn ^:args2 -> f ^$args ^$args2

## Run a command that produces an output path, where the path to create is passed as an argument to
## the given function.
##
## Arguments: `(Function :function)`
##
## Returns the output path, relying on the value returned by the function. Execution of that value
## _must_ make the path valid for future use.
##
## ### Example Usage
## ```ergo
## out = Path:with-output <| fn :p -> exec touch $$p
## ```
with-output-path = fn :f -> {
    file = plugin:Path:new ()
    f $file
    $file
}

## Match a path value or bind the source path of the value.
##
## Arguments: `:source`
##
## Keyed Arguments:
## * `parent` - if present, the parent directory of the source path will be used.
## * `no-source` - the value to bind if no source information is available, defaulting to
##   `std:env:current-dir`.
##
## When called in a pattern expression and bound, if the bound value is a Path, `source` will be
## bound to that path. Otherwise `source` will be bound to the source path of the bound value, or
## its parent directory if `parent` is present. If the bound value has no source path,
## `default` is bound.
##
## This is of particular use with function arguments to get function call site source paths and
## allow them to be overriden.
path-or-source = fn ^{:parent,no-source = default :no-source as plugin:env:current-dir} :x -> matches [
    plugin:Path :p -> { $x = $p }
    plugin:Unset :u -> {
        $x = plugin:match (plugin:value:source-path $u) [
            plugin:Path :p -> plugin:match $parent [$unset -> $p, _ -> plugin:Path:parent $p]
            $unset -> $no-source
        ]
    }
]

## Create a recursive function. The passed function will be passed itself as the first argument, and
## all other arguments will be forwarded.
##
## Arguments: `(Function :function)`
##
## Returns a function that calls the passed function, forwarding arguments.
##
## When recursively calling the function, you must also pass the function as the first argument.
## *Avoid recursion when possible*, as it is often difficult to reason about value identities and
## behavior in the lazily-evaluated runtime.
##
## ### Example Usage
## ```ergo
## func = Function:recursive <| fn :self :a :b -> {
##    # Recursive call
##    self :self 1 2
## }
##
## # External call
## func 1 2
## ```
recursive = fn :f -> fn ^:args -> f $f ^$args

## Memoize a function (cache the function results based purely on arguments).
##
## Arguments: `(Function :f)`
##
## Returns a function which will share results based on the arguments. Thus, if you call the
## function more than once on the same arguments, it will only be evaluated once with those
## arguments.
memoize = fn (plugin:Function :f) -> fn ^:args -> plugin:value:cache (no-persist=true) <| f ^$args

## Import values by index in a binding expression.
##
## Arguments: `:descriptor`
##
## If passed a Map, each key in the map will be used as an index to the bound value, and each value
## will be bound as if `import` were used.
## Otherwise, bind the result to the binding expression.
##
## Note that all bound values will be evaluated at the binding site.
##
## ### Example Usage
## ```ergo
## # Basic import (no different than normal binding)
## import :s = $$std
##
## # Name import
## import {fs = {:write},:io} = $$std
## write file.txt io:stdin
##
## # Renaming import
## import {path = :stdpath} = $$std
## stdpath:new()
## ```
import = recursive <| fn :self :descr -> :v -> {
    plugin:match $descr [
        plugin:Map :m -> {
            plugin:Iter:map (fn (plugin:MapEntry:@ :key :value) -> { mtype:required (self $self $value) = plugin:value:source-copy $key v:$key }) $m
            ()
        }
        :other -> { $other = $v }
    ]
}

## Check whether a path exists.
##
## Arguments: `(Path :path)`
##
## Returns a `Bool` indicating whether the path exists and is accessible to the user.
file-exists = fn :p -> plugin:Bool:from <| plugin:fs:file-type $p

## Create a function that also behaves as a module (with indices).
##
## Arguments: `(Function :function) (Map :module)`
##
## This will also appropriately set the documentation of the value based on the documentation of the
## arguments.
function-module = fn :func :module -> {
    mod-doc = plugin:match $module [
        {} -> ""
        _ -> {
            ##mdoc:module
            ##
            module
            "\n\n$(doc $module)"
        }
    ]

    ## $(doc $func)$mod-doc
    :a -> {
        { :result } = plugin:match $a [
            index :i -> plugin:match module:$i [
                $unset -> plugin:Error:new (source = $module) "missing index: $i"
                :x -> { result = $x }
            ]
            # We want the binding to occur immediately, but if there is an error we do not want to make
            # `match` consider it a match error and move on (to improve the overall error reported in
            # this case).
            :other -> { result = bind $func $other }
        ]
        $result
    }
}

## Split an iterator after the first `n` elements.
##
## Arguments: `(String :n) (Into<Iter> :iter)`
##
## Returns a 2-value array where the first value is an Iter with the first `n` values, and the
## second is an Iter with all remaining values.
iter-split = fn :n :iter -> [plugin:Iter:take $n $iter, plugin:Iter:skip $n $iter]

## Conditionally return a value.
##
## Arguments: `(Into Bool |> :condition) :if_true [else if :cond2 :if_true2]... [else :if_false]`
##
## If `condition` evaluates to true, `if_true` is returned. Otherwise each following `cond2` is
## subsequently tested (returning `if_true2` if one evaulates to true), and `if_false` is returned
## if no conditions evaluate to true. If the else condition is omitted, `unset` will be returned.
if = fn :cond :if_true ^:rest -> {
    do-condition = recursive <| fn :self :cond :if_true :rest -> {
        plugin:match (plugin:Bool:from $cond) [
            plugin:Bool:true -> $if_true
            plugin:Bool:false -> plugin:match $rest [
                [else,if,:cond2,:if_true2,^:rest] -> self $self $cond2 $if_true2 $rest
                [else,:if_false] -> $if_false
                [] -> $unset
                [:other,^_] -> plugin:Error:new (source=$other) "expected `else` or `else if`"
            ]
        ]
    }
    do-condition $cond $if_true (plugin:Array:from <| $rest)
}

## Create a function which takes only string arguments as interpreted by `std:getopt`.
##
## Arguments: `^:args`
##
## Passes all positional arguments to `std:getopt` and binds the result to the pattern arguments.
getopt-fn = :patargs -> :args -> { $patargs = plugin:getopt args:positional }

## Map a possibly-Unset value.
##
## Arguments: `(Function :f) :value`
##
## If `value` is Unset, returns `value`, otherwise return `f` applied to `value`.
unset-map = fn :f :v -> plugin:match $v [$unset -> $v, _ -> f $v]

## Bind a value to each binding provided.
##
## Arguments: `^:cases`
##
## When bound with a value `v`, binds each value in `cases` with `v`, failing if any encounter an
## error.
bind-and = fn ^:cases -> :v -> {
    plugin:Iter:map (fn :case -> { $case = $v }) cases:positional
    ()
}

## Bind a value to at least one of the bindings provided.
##
## Arguments: `^:cases`
##
## When bound with a value `v`, binds each value in `cases` with `v` until one does not error, and
## produces an error if none match.
bind-or = fn ^:cases -> :v -> plugin:match $v cases:positional

## Extend a type with the given map of indices.
extend-type = fn :tp :map -> plugin:Type:modify $tp <| plugin:value:merge (plugin:Type:index $tp) $map

##mdoc:module
## The ergo standard library.
##
## This library provides a number of submodules that group related functions, as well as some
## top-level functions. It is often useful to use `std:import` to import subsets of functionality
## from the library.
{
    ##mdoc:module
    ## Arrays of values.
    Array = extend-type plugin:Array {
        values = mtype:array-values
        of = mtype:array-of
    }

    ##mdoc:module
    ## Boolean values.
    Bool = plugin:Bool

    ##mdoc:module
    ## Runtime errors.
    Error = plugin:Error

    ##mdoc:module
    ## Functions and unbound values.
    Function = extend-type plugin:Function {memoize,partial,pass,recursive,module = $function-module}

    ##mdoc:module
    ## Iterators producing values.
    Iter = extend-type plugin:Iter {split = $iter-split}

    ##mdoc:module
    ## Maps of values.
    Map = extend-type plugin:Map {
        values = mtype:map-values
        of = mtype:map-of
    }

    ##mdoc:module
    ## A single entry for a Map.
    MapEntry = plugin:MapEntry

    ##mdoc:module
    ## Arbitrary rational numbers.
    Number = plugin:Number

    ##mdoc:module
    ## Ordering values.
    Order = plugin:Order

    ##mdoc:module
    ## File paths.
    Path = extend-type plugin:Path {with-output = $with-output-path, or-source = $path-or-source}

    ##mdoc:module
    ## Strings.
    String = plugin:String

    ##mdoc:module
    ## The Type of Types.
    Type = extend-type plugin:Type {
        import {:enum,:struct,:pass,:or} = $mtype
    }

    ##mdoc:module
    ## Unit (void) type.
    Unit = plugin:Unit

    ##mdoc:module
    ## Unset type.
    Unset = extend-type plugin:Unset {map = $unset-map}

    ##mdoc:module
    ## Binding helpers.
    bind = {
        and = $bind-and
        or = $bind-or
    }

    ##mdoc:module
    ## Documentation helpers.
    doc = $mdoc

    ##mdoc:module
    ## Interact with dynamic bindings.
    ##
    ## A dynamic binding is a binding that has dynamic scope, meaning that it is retrieved at
    ## evaluation time, and is still bound through function calls and other evaluation. This can be
    ## used, for example, to set global context that will be used.
    ##
    ## Generally dynamic bindings are a bit tricky to reason about since there are no syntactic
    ## hints about when they will be present, so take this into consideration when using them.
    dynamic = plugin:value:dynamic

    ##mdoc:module
    ## Get values related to the program's runtime environment.
    env = plugin:env

    ##mdoc:module
    ## Interact with the local filesystem.
    fs = { ^plugin:fs, exists = $file-exists }

    ##mdoc:module
    ## Interact with the program's io channels.
    io = plugin:io

    ##mdoc:module
    ## JSON functions.
    ##
    ## JSON types map to native ergo types in the following way:
    ## * null <-> `Unit`
    ## * string <-> `String`
    ## * number <-> `Number`
    ## * boolean <-> `Bool`
    ## * object <-> `Map`
    ## * array <-> `Array`
    json = plugin:json

    ## The runtime logging interface.
    ##
    ## Loggers support the following indices:
    ## * `debug`/`info`/`warn`/`error` - Display the argument at the given log level.
    ## * `sublog` - Create a new sublogger from this logger, with the given name argument.
    log = plugin:log

    ##mdoc:module
    ## Manipulate value metadata.
    ##
    ## Values can have arbitrary metadata attached to them at runtime. This metadata can be
    ## retrieved without evaluating the value.
    meta = plugin:value:meta

    ##mdoc:module
    ## Networking functions.
    net = $mnet

    ##mdoc:module
    ## Value source location functions.
    source = {
        copy = plugin:value:source-copy
        ## Get the source directory of a value.
        ##
        ## Arguments: `:value`
        ##
        ## Returns the parent directory of the source path of `value`, or Unset if no source path is
        ## available.
        dir = fn :x -> unset-map plugin:Path:parent <| plugin:value:source-path $x
        path = plugin:value:source-path
        ## Map a function on a value, retaining the value's source.
        ##
        ## Arguments: `(Function :f) :value`
        map = fn :f :v -> plugin:value:source-copy $v (f $v)
    }

    ##mdoc:module
    ## Synchronization functions.
    sync = plugin:sync

    ##mdoc:module
    ## Test helper functions.
    test = $mtest

    # Functions
    import {:cache,:debug,:equal,:identity,:merge,:variable} = plugin:value
    import {:optional,:required} = $mtype
    default
    ergo-remote
    exec = plugin:exec
    getopt = function-module plugin:getopt {fn = $getopt-fn}
    import
    if
    match = function-module plugin:match {value = $matches}
    task = plugin:task
}
