plugin = ergo plugin

native-doc = :doc

## Create a value that will evaluate to the first argument which successfully binds.
## 
## Arguments: `(Array :cases)`
##
## This is a shortcut for `:a -> match :a :cases`.
matches = fn :cases -> :a -> !plugin:match :a :cases

mdoc = ergo doc
mnet = ergo net
mtype = ergo type

## {{native-doc plugin:value:eval}}
##
## Pattern Arguments: `:value`
##
## When used in a pattern, evaluates the bound value before binding to the argument.
eval = matches [
    fn :x -> plugin:value:eval :x
    pat :out -> :x -> bind :out (!plugin:value:eval :x)
]

## Load a remote archive.
##
## Fetches the archive with `net:unarchive-remote`, and loads the archive from the root directory.
##
## Arguments: `(String :url)`
ergo-remote = fn :url -> ergo <| mnet:unarchive-remote :url

## Return any bound value as-is.
##
## Particularly useful as a case in `match` calls.
pass = :v -> :v

## Use a default value if Unset.
##
## Arguments: `:target as :value`
##
## Ensure that `value` is evaluated as a normal expression in pattern expressions (typically
## preceded by `!`, though not always necessary if the value doesn't use get/set syntax).
##
## If the value bound to the result is `Unset`, the default is used.
##
## ### Example Usage
## ```ergo
## :v = default :my-value as []
## default :my-value as [] = :maybe-an-array
## func = fn (opt-arg = default :arg as []) -> {...}
## ```
default = matches [
    fn :v as :default-value -> {
        !plugin:match :v [plugin:type:Unset -> :default-value, :pass]
    }
    pat :out as :default-value -> :v -> {
        bind :out <| !plugin:match :v [plugin:type:Unset -> :default-value, :pass]
    }
]

## Partially apply a function.
##
## Arguments: `(Function :func) ^:args`
##
## Returns a `Function` that, when called, will call the original function with the original arguments
## and any extra arguments of the call.
##
## ### Example Usage
## ```ergo
## f = fn :a :b :c -> [:a,:b,:c]
## part = Function:partial :f 1 2
## [1,2,3] = part 3
## [1,2,a] = part a
## ```
partial = fn :f ^:args -> fn ^:args2 -> f ^:args ^:args2

## Run a command that produces an output path, where the path to create is passed as an argument to
## the given function.
##
## Arguments: `(Function :function)`
##
## Returns the output path, relying on the value returned by the function. Execution of that value
## _must_ make the path valid for future use.
##
## ### Example Usage
## ```ergo
## out = Path:with-output <| fn :p -> exec touch :p
## ```
with-output-path = fn :f -> {
    file = plugin:path:new:
    { !f :file, :file }
}

## Match a path value or bind the source path of the value.
##
## Pattern Arguments: `:source`
##
## Pattern Keyed Arguments:
## * `parent` - if present, the parent directory of the source path will be used.
## * `no-source` - the value to bind if no source information is available, defaulting to
##   `std:env:current-dir`.
##
## When called in a pattern expression and bound, if the bound value is a Path, `source` will be
## bound to that path. Otherwise `source` will be bound to the source path of the bound value, or
## its parent directory if `parent` is present. If the bound value has no source path,
## `default` is bound.
##
## This is of particular use with function arguments to get function call site source paths and
## allow them to be overriden.
path-or-source = pat ^{parent,no-source = default :no-source as plugin:env:current-dir} :x -> matches [
    plugin:type:Path :p -> bind :x :p
    :other -> bind :x <| plugin:match (plugin:value:source-path :other) [
        plugin:type:Path :p -> plugin:match :parent [plugin:type:Unset -> :p, _ -> plugin:path:parent :p]
        plugin:type:Unset -> :no-source
    ]
]

## Create a recursive function. The passed function will be passed itself as the first argument, and
## all other arguments will be forwarded.
##
## Arguments: `(Function :function)`
##
## Returns a function that calls the passed function, forwarding arguments.
##
## When recursively calling the function, you must also pass the function as the first argument.
## *Avoid recursion when possible*, as it is often difficult to reason about value identities and
## behavior in the lazily-evaluated runtime.
##
## ### Example Usage
## ```ergo
## func = Function:recursive <| fn :self :a :b -> {
##    # Recursive call
##    self :self 1 2
## }
##
## # External call
## func 1 2
## ```
recursive = fn :f -> fn ^:args -> f :f ^:args

## Memoize a function (cache the function results based purely on arguments).
##
## Arguments: `(Function :f)`
##
## Returns a function which will share results based on the arguments. Thus, if you call the
## function more than once on the same arguments, it will only be evaluated once with those
## arguments.
memoize = fn (plugin:type:Function :f) -> fn ^:args -> plugin:value:cache (no-persist=true) <| f ^:args

## Import values by index in a binding expression.
##
## Arguments: `(MapOrValue :descriptor)`
##
## If passed a map, each key in the map will be used as an index to the bound value, and each value
## will be bound as if `import` were used.
## Otherwise, bind the result to the binding expression.
##
## ### Example Usage
## ```ergo
## # Basic import (no different than normal binding)
## import :s = std:
##
## # Name import
## import {fs = {write},io} = std:
## write file.txt io:stdin
##
## # Renaming import
## import {path = :stdpath} = std:
## stdpath:new:
## ```
import = {
    inner = recursive <| fn :self :descr -> :v -> {
        plugin:match :descr [
            plugin:type:Map :m -> {
                plugin:iter:map (fn (plugin:type:MapEntry: :key :value) -> { fn (mtype:required !(self :self :value)) -> () |> v::key }) :m
                ()
            }
            :other -> bind :other :v
        ]
    }

    pat :descr -> inner :descr
}

match-indices = fn :fallback :from -> {
    matches [
        index :i -> !plugin:match from::i [
            plugin:type:Unset -> !plugin:type:Error: (source = :from) <| plugin:string:format "missing index: {}" :i
            :pass
        ]
        :fallback
    ]
}

type-function = {
    binding = (
"When called on a single value, checks whether the value is the type (if statically typed) or
creates a typed value from a dynamically typed value (checking the type when evaluated).

When called in a pattern on a single argument, checks that the bound value is the type, and then
binds that value to the argument (behaving the same way for static/dynamic typed values).

If bound directly to a value (versus calling with an argument), checks that the bound value is the
type."
    )
    compose = (
"If called without arguments, returns a composition function which can be used to compose or
decompose instances of the type."
    )
    matches [
        fn: -> :binding
        fn :args -> plugin:string:format "{}\n\n{}\nArguments: `{}`" :binding :compose :args
    ]
}

## Split an iterator after the first `n` elements.
##
## Arguments: `(String :n) (Into<Iter> :iter)`
##
## Returns a 2-value array where the first value is an Iter with the first `n` values, and the
## second is an Iter with all remaining values.
iter-split = fn :n :iter -> [plugin:iter:take :n :iter, plugin:iter:skip :n :iter]

## Conditionally return a value.
##
## Arguments: `(Into<Bool> :condition) :if_true (optional :if_false)`
##
## If `condition` evaluates to true, `if_true` is returned. Otherwise `if_false` is returned. If
## `if_false` is omitted, an Unset value will be returned.
if = fn :cond :if_true ^:if_false -> plugin:match (plugin:bool:from :cond) [
    plugin:bool:true -> :if_true
    plugin:bool:false -> plugin:match if_false:positional [
        [] -> :unset
        [:if_false] -> :if_false
        [_,^:rest] -> plugin:type:Error: (source=:rest) "too many arguments supplied to if"
    ]
    #[plugin:bool:false, [:if_false]] -> :if_false
]

## Create a function which takes only string arguments as interpreted by `std:getopt`.
##
## Pattern Arguments: `^:args`
##
## Passes all positional arguments to `std:getopt` and binds the result to the pattern arguments.
getopt-fn = :patargs -> :args -> bind :patargs <| plugin:getopt args:positional

## Map a possibly-Unset value.
##
## Arguments: `(Function :f) :value`
##
## If `value` is Unset, returns `value`, otherwise return `f` applied to `value`.
unset-map = fn :f :v -> plugin:match :v [plugin:type:Unset -> :v, _ -> f :v]

## Bind a value to each binding provided.
##
## Pattern Arguments: `^:cases`
##
## When bound with a value `v`, binds each value in `cases` with `v`, failing if any encounter an
## error.
bind-and = pat ^:cases -> :v -> {
    plugin:iter:map (fn :case -> bind :case :v) cases:positional
    ()
}

## Bind a value to at least one of the bindings provided.
##
## Pattern Arguments: `^:cases`
##
## When bound with a value `v`, binds each value in `cases` with `v` until one does not error, and
## produces an error if none match.
bind-or = pat ^:cases -> :v -> plugin:match :v cases:posiitonal

## The ergo standard library.
##
## This library provides a number of submodules that group related functions, as well as some
## top-level functions. It is often useful to merge the library into the top-level environment, for
## instance with `^ergo std`.
##
## # Types
## {{mdoc:modules :self Any Array Bool Error Function Iter Map MapEntry Number Path String Unit Unset}}
##
## # Modules
## {{mdoc:modules :self bind doc dynamic env fs io json log meta net source type}}
##
## # Functions
## {{(mdoc:functions :self by-content cache debug default ergo-remote
##    eval exec getopt identity if import match optional required task
##    variable)}}
{
    ## The Any type.
    ##
    ## This type will always match the given value.
    ##
    ## {{type-function:}}
    Any = plugin:type:Any

    ## The Array type and related functions.
    ##
    ## {{type-function:}}
    ##
    ## # Functions
    ## {{mdoc:functions :self from Values Of}}
    Array = match-indices plugin:type:Array {
        import {from} = plugin:array
        Values = mtype:ArrayValues
        Of = mtype:ArrayOf
    }

    ## The Bool type and related functions.
    ##
    ## {{type-function:}}
    ##
    ## # Functions
    ## {{mdoc:functions :self from true false}}
    Bool = match-indices plugin:type:Bool plugin:bool

    ## The Error type.
    ##
    ## {{type-function "(source) :message"}}
    Error = plugin:type:Error

    ## The Function type and related functions.
    ##
    ## {{type-function:}}
    ##
    ## # Functions
    ## {{mdoc:functions :self memoize partial pass recursive}}
    Function = match-indices plugin:type:Function {memoize,partial,pass,recursive}

    ## The Iter type and related functions.
    ##
    ## Iter types can be used to manipulate collections of values All functions here (when taking an
    ## some iterator argument) convert the argument to an Iter if possible. So, for example, one can
    ## you these functions directly on arrays and maps (but you should take care to convert the
    ## resulting Iters back to arrays and maps when necessary).
    ##
    ## {{type-function:}}
    ##
    ## # Functions
    ## {{
    ##   (mdoc:functions :self from fold filter flatten map map-lazy no-errors skip skip-while
    ##    split take take-while unique zip)
    ## }}
    Iter = match-indices plugin:type:Iter {^plugin:iter, split = :iter-split}

    ## The Map type and related functions.
    ##
    ## When converting a map to/from an iterator, the iterator elements will/must be `MapEntry` types.
    ##
    ## {{type-function:}}
    ##
    ## # Functions
    ## {{mdoc:functions :self from Values Of}}
    Map = match-indices plugin:type:Map {
        import {from} = plugin:map
        Values = mtype:MapValues
        Of = mtype:MapOf
    }

    ## The MapEntry type.
    ##
    ## This type supports indexing with `key` and `value`.
    ##
    ## {{type-function ":key :value"}}
    MapEntry = plugin:type:MapEntry

    ## The Number type and related functions.
    ##
    ## Numbers are arbitrarily large rationals. They may be expressed as integers, decimals, or
    ## rationals such as `1/2`.
    ##
    ## {{type-function ":number"}}
    ##
    ## # Functions
    ## {{mdoc:functions :self from}}
    Number = match-indices plugin:type:Number plugin:number

    ## The Path type and related functions.
    ##
    ## {{type-function:}}
    ##
    ## # Functions
    ## {{mdoc:functions :self new join split name or-source parent relative with-output}}
    Path = match-indices plugin:type:Path {^plugin:path, with-output = :with-output-path, or-source = :path-or-source}

    ## The String type and related functions.
    ##
    ## {{type-function:}}
    ##
    ## # Functions
    ## {{mdoc:functions :self chars format from join split trim}}
    String = match-indices plugin:type:String plugin:string

    ## The Unit type.
    ##
    ## {{type-function:}}
    Unit = plugin:type:Unit

    ## The Unset type.
    ##
    ## {{type-function:}}
    ##
    ## If called with no arguments, returns an Unset instance.
    ##
    ## When indexing maps, `Unset` is returned if a key does not exist.
    ## To remove values from a map, you may bind them to `Unset` values.
    ##
    ## # Functions
    ## {{mdoc:functions :self map}}
    Unset = match-indices plugin:type:Unset {map = :unset-map}

    ## Binding helpers.
    ##
    ## # Functions
    ## {{mdoc:functions :self and or}}
    bind = {
        and = :bind-and
        or = :bind-or
    }

    ## Documentation helpers.
    ##
    ## {{mdoc:functions :self summary modules functions}}
    doc = :mdoc

    ## Interact with dynamic bindings.
    ##
    ## A dynamic binding is a binding that has dynamic scope, meaning that it is retrieved at
    ## evaluation time, and is still bound through function calls and other evaluation. This can be
    ## used, for example, to set global context that will be used. Note that dynamic bindings _are
    ## not_ automatically tracked in identity derivation, so care _must_ be taken to ensure that if
    ## the value of the dynamic binding is relevant to an identity, it is queried sooner (for
    ## instance using `!`).
    ##
    ## Generally dynamic bindings are a bit tricky to reason about since there are no syntactic
    ## hints about when they will be present, so take this into consideration when using them.
    ##
    ## {{mdoc:functions :self get eval}}
    dynamic = plugin:value:dynamic

    ## Get values related to the program's runtime environment.
    ##
    ## {{mdoc:functions :self get path-search home current-dir user-cache system-cache os arch}}
    env = plugin:env

    ## Interact with the local filesystem.
    ##
    ## {{
    ## (mdoc:functions :self append archive copy create-dir exists glob read remove sha1 track unarchive
    ##  write)
    ## }}
    fs = plugin:fs

    ## Interact with the program's io channels.
    ##
    ## {{mdoc:functions :self stdin stdout stderr}}
    io = plugin:io

    ## JSON functions.
    ##
    ## JSON types map to native ergo types in the following way:
    ## * null <-> `Unit`
    ## * string <-> `String`
    ## * number <-> `Number`
    ## * boolean <-> `Bool`
    ## * object <-> `Map`
    ## * array <-> `Array`
    ##
    ## # Functions
    ## {{mdoc:functions :self parse stringify}}
    json = plugin:json

    ## The runtime logging interface.
    ##
    ## # Functions
    ## {{mdoc:functions :self sublog debug info warn error}}
    log = plugin:log

    ## Manipulate value metadata.
    ##
    ## Values can have arbitrary metadata attached to them at runtime. This metadata can be
    ## retrieved without evaluating the value.
    ##
    ## {{mdoc:functions :self get set}}
    meta = plugin:value:meta

    ## Networking functions.
    ##
    ## {{mdoc:functions :self download http unarchive-remote}}
    net = {
        import {download, unarchive-remote} = :mnet
        import { http } = plugin:net
    }

    ## Value source location functions.
    ##
    ## {{mdoc:functions :self copy dir path map}}
    source = {
        copy = plugin:value:source-copy
        ## Get the source directory of a value.
        ##
        ## Arguments: `:value`
        ##
        ## Returns the parent directory of the source path of `value`, or Unset if no source path is
        ## available.
        dir = fn :x -> unset-map plugin:path:parent <| plugin:value:source-path :x
        path = plugin:value:source-path
        ## Map a function on a value, retaining the value's source.
        ##
        ## Arguments: `(Function :f) :value`
        map = fn :f :v -> plugin:value:source-copy :v (f :v)
    }

    ## Type creation.
    ##
    ## {{mdoc:functions :self new enum struct Or}}
    type = {
        import {new,Or} = plugin:type
        import {enum,struct} = :mtype
    }

    # Functions
    import {by-content,cache,debug,identity,variable} = plugin:value
    import {optional,required} = :mtype
    default
    ergo-remote
    eval
    exec = plugin:exec
    ## {{native-doc plugin:getopt}}
    ##
    ## # Functions
    ## {{mdoc:functions :self fn}}
    getopt = match-indices plugin:getopt {fn = getopt-fn}
    import
    if
    ## {{native-doc plugin:match}}
    ##
    ## # Functions
    ## {{mdoc:functions :self value}}
    match = match-indices plugin:match {value = :matches}
    task = plugin:task
}
