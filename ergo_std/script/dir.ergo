plugin = ergo plugin

## Create a value that will evaluate to the first argument which successfully binds.
## 
## Arguments: `(Array :cases)`
##
## This is a shortcut for `:a -> match :a :cases`.
matches = fn :cases -> :a -> plugin:match :a :cases

mdoc = ergo doc
mnet = ergo net
mtest = ergo test
mtype = ergo type

## ^(doc plugin:value:eval)
##
## Pattern Arguments: `:value`
##
## When used in a pattern, evaluates the bound value before binding to the argument.
eval = :a -> plugin:value:eval <| plugin:match :a [
    fn :x -> { plugin:value:eval :x }
    pat :out -> :x -> bind :out (force <| plugin:value:eval :x)
]

## Load a remote archive.
##
## Fetches the archive with `net:unarchive ^^enter`, and loads the archive from the root directory.
## Caches the returned value.
##
## All arguments are forwarded to `std:net:http`.
ergo-remote = fn ^:args -> ergo <| plugin:value:cache <| mnet:unarchive ^enter ^:args

## Return any bound value as-is.
##
## Particularly useful as a case in `match` calls.
pass = :v -> :v

## Use a default value if Unset.
##
## Arguments: `:target as :value`
##
## Ensure that `value` is evaluated as a normal expression in pattern expressions (typically
## preceded by `!`, though not always necessary if the value doesn't use get/set syntax).
##
## If the value bound to the result is `Unset`, the default is used.
##
## ### Example Usage
## ```ergo
## :v = default :my-value as []
## default :my-value as [] = :maybe-an-array
## func = fn (opt-arg = default :arg as []) -> {...}
## ```
default = matches [
    fn :v as :default-value -> plugin:match :v [plugin:type:Unset -> :default-value, :pass]
    pat :out as :default-value -> :v -> {
        bind :out <| plugin:match :v [plugin:type:Unset -> :default-value, :pass]
    }
]

## Partially apply a function.
##
## Arguments: `(Function :func) ^^:args`
##
## Returns a `Function` that, when called, will call the original function with the original arguments
## and any extra arguments of the call.
##
## ### Example Usage
## ```ergo
## f = fn :a :b :c -> [:a,:b,:c]
## part = Function:partial :f 1 2
## [1,2,3] = part 3
## [1,2,a] = part a
## ```
partial = fn :f ^:args -> fn ^:args2 -> f ^:args ^:args2

## Run a command that produces an output path, where the path to create is passed as an argument to
## the given function.
##
## Arguments: `(Function :function)`
##
## Returns the output path, relying on the value returned by the function. Execution of that value
## _must_ make the path valid for future use.
##
## ### Example Usage
## ```ergo
## out = Path:with-output <| fn :p -> exec touch :p
## ```
with-output-path = fn :f -> {
    file = plugin:path:new()
    { f :file, :file }
}

## Match a path value or bind the source path of the value.
##
## Pattern Arguments: `:source`
##
## Pattern Keyed Arguments:
## * `parent` - if present, the parent directory of the source path will be used.
## * `no-source` - the value to bind if no source information is available, defaulting to
##   `std:env:current-dir`.
##
## When called in a pattern expression and bound, if the bound value is a Path, `source` will be
## bound to that path. Otherwise `source` will be bound to the source path of the bound value, or
## its parent directory if `parent` is present. If the bound value has no source path,
## `default` is bound.
##
## This is of particular use with function arguments to get function call site source paths and
## allow them to be overriden.
path-or-source = pat ^{parent,no-source = default :no-source as plugin:env:current-dir} :x -> matches [
    plugin:type:Path :p -> bind :x :p
    plugin:type:Unset :u -> bind :x <| plugin:match (plugin:value:source-path :u) [
        plugin:type:Path :p -> plugin:match :parent [plugin:type:Unset -> :p, _ -> plugin:path:parent :p]
        plugin:type:Unset -> :no-source
    ]
]

## Create a recursive function. The passed function will be passed itself as the first argument, and
## all other arguments will be forwarded.
##
## Arguments: `(Function :function)`
##
## Returns a function that calls the passed function, forwarding arguments.
##
## When recursively calling the function, you must also pass the function as the first argument.
## *Avoid recursion when possible*, as it is often difficult to reason about value identities and
## behavior in the lazily-evaluated runtime.
##
## ### Example Usage
## ```ergo
## func = Function:recursive <| fn :self :a :b -> {
##    # Recursive call
##    self :self 1 2
## }
##
## # External call
## func 1 2
## ```
recursive = fn :f -> fn ^:args -> f :f ^:args

## Memoize a function (cache the function results based purely on arguments).
##
## Arguments: `(Function :f)`
##
## Returns a function which will share results based on the arguments. Thus, if you call the
## function more than once on the same arguments, it will only be evaluated once with those
## arguments.
memoize = fn (plugin:type:Function :f) -> fn ^:args -> plugin:value:cache (no-persist=true) <| f ^:args

## Import values by index in a binding expression.
##
## Arguments: `(MapOrValue :descriptor)`
##
## If passed a map, each key in the map will be used as an index to the bound value, and each value
## will be bound as if `import` were used.
## Otherwise, bind the result to the binding expression.
##
## Note that all bound values will be evaluated at the binding site.
##
## ### Example Usage
## ```ergo
## # Basic import (no different than normal binding)
## import :s = :std
##
## # Name import
## import {fs = {write},io} = :std
## write file.txt io:stdin
##
## # Renaming import
## import {path = :stdpath} = :std
## stdpath:new()
## ```
import = {
    inner = recursive <| fn :self :descr -> :v -> {
        plugin:match :descr [
            plugin:type:Map :m -> {
                plugin:iter:map (fn (plugin:type:MapEntry:@ :key :value) -> { fn (mtype:required (source=!:key) !(self :self :value)) -> () |> v::key }) :m
                ()
            }
            :other -> bind :other :v
        ]
    }

    pat :descr -> inner :descr
}

## Check whether a path exists.
##
## Arguments: `(Path :path)`
##
## Returns a `Bool` indicating whether the path exists and is accessible to the user.
file-exists = fn :p -> plugin:bool:from <| plugin:fs:file-type :p

## Create a function that also behaves as a module (with indices).
##
## Arguments: `(Function :function) (Map :module)`
##
## This will also appropriately set the documentation of the value based on the documentation of the
## arguments.
function-module = fn :func :module -> {
    mod-doc = plugin:match :module [
        {} -> ""
        _ -> {
            ##mdoc:module
            ##
            module
            "\n\n^(doc :module)"
        }
    ]

    ## ^(doc :func)^mod-doc
    :a -> {
        { result } = plugin:match :a [
            index :i -> plugin:match module::i [
                plugin:type:Unset -> plugin:type:Error:@ (source = :module) <| plugin:string:format "missing index: {}" :i
                :x -> { result = :x }
            ]
            # We want the binding to occur immediately, but if there is an error we do not want to make
            # `matches` consider it a match error and move on (to improve the overall error reported in
            # this case).
            :other -> { result = bind :func :other }
        ]
        :result
    }
}

make-type = fn :tp ^{compose-args} :index-map -> {
    index-map = {
        ^plugin:match :compose-args [
            plugin:type:Unset -> {}
            :a -> {
                ## Compose/decompose the type.
                ##
                ## Arguments: `^a`
                @ = tp:@
            }
        ]
        ^:index-map
    }

    ##mdoc:type
    function-module :tp :index-map
}

## Split an iterator after the first `n` elements.
##
## Arguments: `(String :n) (Into<Iter> :iter)`
##
## Returns a 2-value array where the first value is an Iter with the first `n` values, and the
## second is an Iter with all remaining values.
iter-split = fn :n :iter -> [plugin:iter:take :n :iter, plugin:iter:skip :n :iter]

## Conditionally return a value.
##
## Arguments: `(Into<Bool> :condition) :if_true [else if :cond2 :if_true2]... [else :if_false]`
##
## If `condition` evaluates to true, `if_true` is returned. Otherwise each following `cond2` is
## subsequently tested (returning `if_true2` if one evaulates to true), and `if_false` is returned
## if no conditions evaluate to true. If the else condition is omitted, `unset` will be returned.
if = fn :cond :if_true ^:rest -> {
    do-condition = recursive <| fn :self :cond :if_true :rest -> {
        plugin:match (plugin:bool:from :cond) [
            plugin:bool:true -> :if_true
            plugin:bool:false -> plugin:match :rest [
                [else,if,:cond2,:if_true2,^:rest] -> self :self :cond2 :if_true2 :rest
                [else,:if_false] -> :if_false
                [] -> :unset
                [:other,^_] -> plugin:type:Error:@ (source=:other) "expected `else` or `else if`"
            ]
        ]
    }
    do-condition :cond :if_true (plugin:array:from <| :rest)
}

## Create a function which takes only string arguments as interpreted by `std:getopt`.
##
## Pattern Arguments: `^^:args`
##
## Passes all positional arguments to `std:getopt` and binds the result to the pattern arguments.
getopt-fn = :patargs -> :args -> bind :patargs <| plugin:getopt args:positional

## Map a possibly-Unset value.
##
## Arguments: `(Function :f) :value`
##
## If `value` is Unset, returns `value`, otherwise return `f` applied to `value`.
unset-map = fn :f :v -> plugin:match :v [plugin:type:Unset -> :v, _ -> f :v]

## Bind a value to each binding provided.
##
## Pattern Arguments: `^^:cases`
##
## When bound with a value `v`, binds each value in `cases` with `v`, failing if any encounter an
## error.
bind-and = pat ^:cases -> :v -> {
    plugin:iter:map (fn :case -> bind :case :v) cases:positional
    ()
}

## Bind a value to at least one of the bindings provided.
##
## Pattern Arguments: `^^:cases`
##
## When bound with a value `v`, binds each value in `cases` with `v` until one does not error, and
## produces an error if none match.
bind-or = pat ^:cases -> :v -> plugin:match :v cases:positional

##mdoc:module
## The ergo standard library.
##
## This library provides a number of submodules that group related functions, as well as some
## top-level functions. It is often useful to use `std:import` to import subsets of functionality
## from the library.
##
## All values considered "types" support being called on a value (which will evaluate that value and
## check whether the type matches, returning an Error if not) or being called with a single pattern
## in pattern calls (to check the type and bind the result to the given value). For example:
## `std:String :s = :value` checks whether `value` is a string and binds the result (if it is a
## string) to `s`; `std:String :value` checks `value` and returns the evaluated result.
{
    Any = make-type mtype:Any {}

    Typed = make-type plugin:type:Typed {}

    Array = make-type plugin:type:Array {
        import {from} = plugin:array
        Values = mtype:ArrayValues
        Of = mtype:ArrayOf
    }

    Bool = make-type plugin:type:Bool plugin:bool

    Error = make-type plugin:type:Error plugin:error (compose-args = "^^{source} :message")

    Function = make-type plugin:type:Function {memoize,partial,pass,recursive,module = :function-module}

    Iter = make-type plugin:type:Iter {^plugin:iter, split = :iter-split}

    Map = make-type plugin:type:Map {
        import {from} = plugin:map
        Values = mtype:MapValues
        Of = mtype:MapOf
    }

    MapEntry = make-type plugin:type:MapEntry {} (compose-args = ":key :value")

    Number = make-type plugin:type:Number plugin:number (compose-args = ":number")

    Order = make-type plugin:type:Order plugin:cmp

    Path = make-type plugin:type:Path {^plugin:path, with-output = :with-output-path, or-source = :path-or-source}

    String = make-type plugin:type:String plugin:string

    Unit = make-type plugin:type:Unit {}

    Unset = make-type plugin:type:Unset {map = :unset-map}

    ##mdoc:module
    ## Binding helpers.
    bind = {
        and = :bind-and
        or = :bind-or
    }

    ##mdoc:module
    ## Documentation helpers.
    doc = :mdoc

    ##mdoc:module
    ## Interact with dynamic bindings.
    ##
    ## A dynamic binding is a binding that has dynamic scope, meaning that it is retrieved at
    ## evaluation time, and is still bound through function calls and other evaluation. This can be
    ## used, for example, to set global context that will be used. Note that dynamic bindings _are
    ## not_ automatically tracked in identity derivation, so care _must_ be taken to ensure that if
    ## the value of the dynamic binding is relevant to an identity, it is queried sooner (for
    ## instance using `!`).
    ##
    ## Generally dynamic bindings are a bit tricky to reason about since there are no syntactic
    ## hints about when they will be present, so take this into consideration when using them.
    dynamic = plugin:value:dynamic

    ##mdoc:module
    ## Get values related to the program's runtime environment.
    env = plugin:env

    ##mdoc:module
    ## Interact with the local filesystem.
    fs = force { ^plugin:fs, exists = :file-exists }

    ##mdoc:module
    ## Interact with the program's io channels.
    io = plugin:io

    ##mdoc:module
    ## JSON functions.
    ##
    ## JSON types map to native ergo types in the following way:
    ## * null <-> `Unit`
    ## * string <-> `String`
    ## * number <-> `Number`
    ## * boolean <-> `Bool`
    ## * object <-> `Map`
    ## * array <-> `Array`
    json = plugin:json

    ## The runtime logging interface.
    ##
    ## Loggers support the following indices:
    ## * `debug`/`info`/`warn`/`error` - Display the argument at the given log level.
    ## * `sublog` - Create a new sublogger from this logger, with the given name argument.
    log = plugin:log

    ##mdoc:module
    ## Manipulate value metadata.
    ##
    ## Values can have arbitrary metadata attached to them at runtime. This metadata can be
    ## retrieved without evaluating the value.
    meta = plugin:value:meta

    ##mdoc:module
    ## Networking functions.
    net = :mnet

    ##mdoc:module
    ## Value source location functions.
    source = {
        copy = plugin:value:source-copy
        ## Get the source directory of a value.
        ##
        ## Arguments: `:value`
        ##
        ## Returns the parent directory of the source path of `value`, or Unset if no source path is
        ## available.
        dir = fn :x -> unset-map plugin:path:parent <| plugin:value:source-path :x
        path = plugin:value:source-path
        ## Map a function on a value, retaining the value's source.
        ##
        ## Arguments: `(Function :f) :value`
        map = fn :f :v -> plugin:value:source-copy :v (f :v)
    }

    ##mdoc:module
    ## Synchronization functions.
    sync = plugin:sync

    ##mdoc:module
    ## Test helper functions.
    test = :mtest

    ##mdoc:module
    ## Type creation.
    type = {
        import {new} = plugin:type
        import {enum,struct} = :mtype
    }

    # Functions
    import {by-content,cache,debug,equal,identity,merge,variable} = plugin:value
    import {optional,required} = :mtype
    default
    ergo-remote
    eval
    exec = plugin:exec
    getopt = function-module plugin:getopt {fn = :getopt-fn}
    import
    if
    match = function-module plugin:match {value = :matches}
    task = plugin:task
}
