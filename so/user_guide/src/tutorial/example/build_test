#!/usr/bin/env so

# Convenience binding for following functions
use_path = { env = { PATH = $ } }

# Compile function, taking one argument indicating the file to compile.
compile = fn {
    incs = map (fn if (has $@:0 includes) (map (fn $ [-I,$@:0]) $@:0:includes) []) $@
    c++ -o { file = obj } $incs -c (track $@:0) $use_path
    obj
}

# Executable-linking function, which links all arguments.
link = fn { c++ -o { file = exe } $@ $use_path; exe }
link_exe = link

# Library-linking function, which links all arguments.
link_so = fn link -shared $@


# Create a library from lib.cpp.
lib = link_so "-Wl,-hlibadd2.so" (compile lib.cpp) 

# Create an executable using the library.
exe = link_exe (compile main.cpp) $lib

# Fetch Catch2, build it and get the outputs
Catch2 = {
    wget "https://github.com/catchorg/Catch2/archive/v2.11.1.tar.gz" -O { file = tarball }
    mkdir { dir = unpack }
    catch_dir = unpack Catch2-2.11.1
    tar -xzf $tarball ${
        pwd = unpack .
        creates = {
            sourcedir = catch_dir .
        }
    }
    cmake -DCMAKE_BUILD_TYPE=Release -S $sourcedir -B { dir = builddir } $use_path
    test = do $[
        (make -j8 ${ pwd = builddir . } $use_path):once
        make test ${ pwd = builddir . }
    ]
    # Run the test suite before returning the library path
    do $[test:once,catch_dir single_include .]
}

# Create lib directory to link named library for testing
libpath = {
    mkdir { dir = libpath }
    do $[
        ln -f $lib (libpath libadd2.so .):once
        libpath .
    ]
}

# Create and run a test executable using the library.
test_prog = link_exe (compile test.cpp { includes = [$Catch2] }) $lib
test = $test_prog {
    env = { LD_LIBRARY_PATH = $libpath }
}

# Link results into the current directory.
link_result = [
    ln -f $exe forty_two
    ln -f $lib libadd2.so
]

# Only link outputs if the tests pass.
do $[
    test:once
    link_result
]
